# itmo-docker-task-5
приложение счетчик

Для запуска выгрузите приложение. Его можно запустить как из uvicorn, предварительно установив пакеты через poetry  
<code>uvicorn main:app --workers=3 --host 0.0.0.0 --port 8000</code> 
или соберите образ из Dockerfile

## Сборка докер-образа
``` docker build -t test_app . ```

### Список API точек:

1. `/ (GET)` - получить текущее значение;
2. `/stat (GET)` - увеличивает значение счетчика и возвращает его значение;
3. `/about (GET)` - вывод инициалов автора.

#### `/` (GET):
```json

0

```

#### `/stat` (GET):
```json
 1
```

#### `/about` (GET):
```
<h3> Hello, Mikhail Ivanov!</h3>
```

#### Добавлено в недавней лабораторной (docker-compose)
C помощью docker-compose запускаем два контейнера (первый с mysql базой, второй – с приложением-счетчиком. Что приложение счетчик, что docker-compose используют .env файл оттуда они настраивают настройки разворчивания субд и подключения к ней. Также в docker-compose встроен healthcheck субд:
```text
docker-compose up
```
Для пересборки контейнеров запускать в случае изменения исходников запускать
```text
docker-compose build
```
Запросы к субд идут через асинхронный драйвер aiomysql. При перезапусках приложения восстанавливается значения счётчика по последней записи таблицы.

# ДОБАВЛЕНО Счетчик с репликацией по веб-сервису через swarm

## 1. Настройка репликации (docker-compose)

### 1.1 Настройка образов
Реплики будут собираться из одинаковых обрзов, которые должны где-то лежать.
В примере будет использован локальный реест, поэтому надо указать, что образ
будет браться именно из него, а не из глобального docker hub
```yaml
	image: 127.0.0.1:10000/name_of_app
```

### 1.2 Настройка количества реплик
Репликация настраивается 2 подпараметрами в параметре deploy:
1) mode - [global, replicated] - Если global это означает, что данный сервис будет запущен ровно в одном экземпляре на всех возможных нодах. А replicated означает, что n-ое кол-во контейнеров для данного сервиса будет запущено на всех возможных нодах.
2) replicas - n-ое кол-во контейнеров

Примеры Конфигураций:
1. Сервис будет запущен ровно в одном экземпляре на всех возможных нодах
```yaml
	deploy:
		mode: global
```
2. Четыре контейнера для данного сервиса будет запущено на всех возможных нодах
```yaml
	deploy:
		mode: replicated
		replicas: 3
```

## 2 Инициализация Swarm
2.1 Инициализация менеджера
```bash
	docker swarm init
```

Отключение менеджера (управляющего роем) 
```bash
	docker swarm leave --force
```

## 3 Реестр
3.1 Инициализируем локальный реестр в котором будут храниться образы
```bash
	docker service create --name test_swarm-registry --publish published=10000,target=5000 registry:2 
```

3.2 Отправляем приложение в реестр:
```bash
	docker-compose push
```
3.2 Если не получится:
```bash
	docker-compose build test-app-swarm
	docker-compose push test-app-swarm
```

Удаление реестра
```bash
	docker service rm test_swarm-registry
```

## 4 Управление кластером
Управлять приложением можно через команду (docker stack)

4.1 Создадим приложение (без переменных окружения)
(Будут созданы и запущены: сеть и сервисы, которые развернуты в контейнеру registry)
```bash
	docker stack deploy --compose-file docker-compose.yaml test-app-swarm
```

4.1 Создадим приложение (с переменными окружения) 
Переменные окружения теперь не считываются с файла и их нужно передавать вручную:
```bash
	env $(cat .env | xargs) docker stack deploy --compose-file docker-compose.yaml test-app-swarm
```

4.2 Посмотреть контейнеры приложения:
```bash
	docker stack services test-app-swarm
```

4.3 Проверка приложения:
```bash
	wget localhost:8000
```

## 5 Удаление
Удаление приложения
```bash
	docker stack rm test-app-swarm
```

Удаление реестра
```bash
	docker service rm test_swarm-registry
```

Отключение менеджера (управляющего роем) 
```bash
	docker swarm leave --force
```
